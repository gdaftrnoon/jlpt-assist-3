// 'use client'
// import { Typography, Container, Button, TableContainer, TableHead, TableRow, TableCell, TableBody, Table, Box, Paper, useTheme, useMediaQuery, Grid, IconButton, Collapse, Dialog, DialogTitle, DialogContent } from "@mui/material"
// import { useEffect, useState } from "react";
// import { BarChart } from '@mui/x-charts/BarChart';
// import { useSession } from "next-auth/react";
// import { InfoOutline } from "@mui/icons-material";
// import React from 'react'


// const ReviewComponent = () => {

//     // getting user session if it exists
//     const { data: session, status } = useSession()
//     const userid = session?.user?.userId

//     const thema = useTheme();
//     const matches = useMediaQuery(thema.breakpoints.up('md'));

//     const fileCount = {
//         'n1': 172,
//         'n2': 91,
//         'n3': 89,
//         'n4': 29,
//         'n5': 33,
//     }

//     const [testMeta, setTestMeta] = useState({})
//     const [page, setPage] = useState(0)
//     const [testMetaSliced, setTestMetaSliced] = useState({})

//     // holds the actual cards of the test the user is viewing
//     const [testCards, setTestCards] = useState({})
//     const [tcPage, setTCpage] = useState(0)
//     const [testCardsSliced, setTestCardsSliced] = useState({})

//     // holds the card in spotlight
//     const [spotlightCard, setSpotlightCard] = useState({})

//     const [knownWordIDs, setKnownWordIDs] = useState([])

//     const [progData, setProgData] = useState([])

//     const [metaTableMsg, setMetaTableMsg] = useState('Loading test data')
//     const [detailTableMsg, setDetailTableMsg] = useState('No data available')

//     const [testDetailDialog, toggleTestDetailDialog] = useState(false)
//     const [testDetail, setTestDetail] = useState()

//     ///////////////////////////////////////// FUNCTIONS ///////////////////////////////////////////////

//     function capitalizeFirstLetter(val) {
//         return String(val).charAt(0).toUpperCase() + String(val).slice(1);
//     }

//     // function to retrieve all word ids, all vocab pages
//     const getUserVocab = async () => {

//         if (session) {

//             // getting user vocab
//             const response = await fetch('/api/GetUserVocab', {
//                 method: 'GET',
//             })

//             const data = await response.json()

//             // if error, show error message
//             if (!response.ok) {
//                 alert(data.message)
//                 setTimeout(() => {
//                     redirect('/')
//                 }, 2000)
//             }

//             if (response.ok && data) {

//                 const knownWordIds = data.message.map(a => Number(a.word_id))
//                 setKnownWordIDs(knownWordIds)

//                 const info = {} // contains vocab data for all n levels
//                 const barchartData = []

//                 // Fetch all levels in parallel
//                 await Promise.all(
//                     Object.keys(fileCount).map(async (level) => {
//                         const fc = fileCount[level];
//                         const pagePromises = [];
//                         for (let index = 1; index <= fc; index++) {
//                             pagePromises.push(
//                                 fetch(`vocab/${level}/${level}_page${index}_v1.json`).then(res => res.json())
//                             );
//                         }
//                         const store = await Promise.all(pagePromises);
//                         info[level] = store.flatMap(x => x);
//                     })
//                 );

//                 console.log('info', info)

//                 Object.keys(info).forEach(level => {
//                     const slugCount = info[level].length
//                     const levelWordIDs = info[level].map(x => x.id)
//                     const knownWordIDsSet = new Set(knownWordIds) // make it a set for speed
//                     const knownWordsOnLevelCount = levelWordIDs.filter(x => knownWordIDsSet.has(x)).length
//                     const completePerc = Math.floor((knownWordsOnLevelCount / slugCount) * 100)
//                     const nData = {
//                         level: level,
//                         completion: completePerc
//                     }
//                     barchartData.push(nData)
//                 })
//                 console.log('barchartdata', barchartData)
//                 setProgData(barchartData)
//             }
//         }
//     }

//     // fetching test metadata only
//     const fetchUserQuizRecords = async (reqtype, qid) => {

//         const response = await fetch('api/GetUserQuizRecords',
//             { method: 'POST', body: JSON.stringify({ RequestType: reqtype, QuizID: qid }) }
//         )
//         const responseMsg = await response.json()

//         if (responseMsg.status === '200' && reqtype === 'meta' && responseMsg.message.length < 1) {
//             setMetaTableMsg('No test records available')
//             return
//         }

//         // pulling metadata
//         if (responseMsg.status === '200' && reqtype === 'meta') {
//             setTestMeta(responseMsg.message)
//             console.log('test metadata', responseMsg.message)
//             setTestMetaSliced(responseMsg.message.slice(page, 4))
//         }
//         // if error pulling metadata
//         else if (responseMsg.status != '200' && reqtype === 'meta') {
//             console.log(responseMsg.message)
//         }
//     }

//     // fetching test data and vocab data from pages
//     const fetchTestData = async (reqtype, qid, nLevel) => {

//         const response = await fetch('api/GetUserQuizRecords',
//             { method: 'POST', body: JSON.stringify({ RequestType: reqtype, QuizID: qid }) }
//         )
//         // [{ word_id: 42, is_correct: false }, ...]
//         const responseMsg = await response.json()

//         // pulling test data
//         if (responseMsg.status === '200' && reqtype === 'data') {

//             setDetailTableMsg('Test details loading')
//             console.log('response', responseMsg.message)

//             const testWordIDs = responseMsg.message.map(x => x.word_id)

//             const allPages = []

//             try {
//                 for (let index = 1; index <= fileCount[nLevel]; index++) {
//                     const data = await (await fetch(`vocab/${nLevel}/${nLevel}_page${index}_v1.json`)).json()
//                     allPages.push(data)
//                 }
//             }

//             catch (error) {
//                 console.log(error)
//             }

//             finally {
//                 const flatPages = allPages.flatMap(x => x)
//                 const testCards = flatPages.filter(x => testWordIDs.includes(x.id))
//                 console.log('testcards', testCards)
//                 const newTestCards = testCards.map(card => ({ ...card, result: responseMsg.message.filter(x => x.word_id === card.id)[0].is_correct }))
//                 console.log('newtestcards', newTestCards)
//                 setTestCards(newTestCards)
//                 setTestCardsSliced(newTestCards.slice(0, 10))
//             }
//         }
//         // if error pulling test data
//         else if (responseMsg.status != '200' && reqtype === 'data') {
//             console.log(responseMsg.message)
//         }
//     }

//     // page change for metadata table
//     const changePage = (direction, page) => {
//         if (direction === 'back' && page > 0) {
//             setPage(page - 1)
//         }
//         if (direction === 'forward' && page < Math.floor(testMeta.length / 4)) {
//             setPage(page + 1)
//         }
//     }

//     // page change for data table
//     const changeTCpage = (direction, tcPage) => {
//         if (direction === 'back' && tcPage > 0) {
//             setTCpage(tcPage - 1)
//         }
//         if (direction === 'forward' && tcPage < Math.floor(testCards.length / 10)) {
//             setTCpage(tcPage + 1)
//         }
//     }

//     const dialogHelper = (index) => {
//         setTestDetail(testMetaSliced[index])
//     }

//     ///////////////////////////////////////// USE EFFECTS ///////////////////////////////////////////////

//     // pulling test metadata on mount
//     useEffect(() => {
//         if (status === 'loading' || status == 'unauthenticated') {
//             setMetaTableMsg('You must be logged in to use the review page')
//             return
//         }
//         else
//             getUserVocab()
//         fetchUserQuizRecords('meta', null)
//     }, [status])

//     // adjusting test metadata table on page change
//     useEffect(() => {
//         if (testMeta.length > 0) {
//             setTestMetaSliced(
//                 testMeta.slice(page * 4, (page * 4) + 4)
//             )
//         }
//     }, [page])

//     // adjusting test data table on tcpage change
//     useEffect(() => {
//         if (testCards.length > 0) {
//             setTestCardsSliced(
//                 testCards.slice(tcPage * 10, (tcPage * 10) + 10)
//             )
//         }
//     }, [tcPage])

//     ////////////////////////////////////////////////////////////////////////////////////////

//     return (

//         <Container sx={{}}>
//             <Grid container spacing={2} sx={{ mt: 6 }}>
//                 {/* bar chart */}
//                 <Grid size={(matches) ? 7 : 12}>
//                     <Paper sx={{}}>
//                         <Typography fontWeight={600} pt={2} textAlign={'center'}>
//                             Vocabulary Progress
//                         </Typography>
//                         <BarChart
//                             slots={{ tooltip: Box }}
//                             loading={session && progData.length < 5 ? true : false}
//                             hideLegend
//                             axisHighlight={{ x: 'band' }}
//                             height={261}
//                             barLabel={(v) => `${v.value}%`}
//                             margin={{ left: 0, right: 25 }}
//                             dataset={progData}
//                             series={[{
//                                 dataKey: 'completion'
//                             }]}
//                             xAxis={[{
//                                 data: ['N1', 'N2', 'N3', 'N4', 'N5']
//                             }]}
//                             yAxis={[{
//                                 min: 0,
//                                 max: 100,
//                                 colorMap: {
//                                     type: 'piecewise',
//                                     thresholds: [50, 70],
//                                     colors: ['#ef9a9a', '#fff176', '#66bb6a'],
//                                 },
//                                 valueFormatter: (value) => `${value}%`
//                             }]}
//                             sx={{
//                                 '& .MuiBarLabel-root': {
//                                     translate: '0px -20px',
//                                     fontWeight: '500'
//                                 },
//                             }}
//                         >
//                         </BarChart>
//                     </Paper>
//                 </Grid>
//                 {/* test metadata */}
//                 <Grid size={(matches) ? 5 : 12}>
//                     <TableContainer component={Paper} sx={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
//                         <Box sx={{ flexGrow: 1, pt: 2 }}>
//                             <Table size="small">
//                                 <TableHead>
//                                     <TableRow>
//                                         <TableCell sx={{ width: '10%', px: 1, mx: 0 }} />
//                                         <TableCell sx={{ width: '25%', px: 0, mx: 0, textAlign: 'center' }}>Date</TableCell>
//                                         <TableCell sx={{ width: '25%', px: 0, mx: 0, textAlign: 'center' }}>Level</TableCell>
//                                         <TableCell sx={{ width: '25%', px: 0, mx: 0, textAlign: 'center' }}>Score</TableCell>
//                                         <TableCell sx={{ width: '15%' }} />
//                                     </TableRow>
//                                 </TableHead>
//                                 <TableBody>
//                                     {(testMeta.length > 0) ?
//                                         testMetaSliced.map((test, index) => (

//                                             <TableRow key={test.quiz_id}>
//                                                 <TableCell sx={{ width: '1%', px: 1, mx: 0 }} >
//                                                     <IconButton>
//                                                         <InfoOutline color="info" fontSize="small" onClick={() => { dialogHelper(index); toggleTestDetailDialog(true) }} />
//                                                     </IconButton>
//                                                 </TableCell>
//                                                 <TableCell sx={{ px: 0, mx: 0, textAlign: 'center' }}>{`${test.created_at.slice(8, 10)}/${test.created_at.slice(5, 7)}/${test.created_at.slice(0, 4)}`}</TableCell>
//                                                 <TableCell sx={{ px: 0, mx: 0, textAlign: 'center' }}>{test.n_level.toUpperCase()}</TableCell>
//                                                 <TableCell sx={{ px: 0, mx: 0, textAlign: 'center' }}> {Math.round(((test.correct) / (test.correct + test.incorrect)) * 100) / 100}</TableCell >
//                                                 <TableCell sx={{ px: 0, mx: 0, textAlign: 'center' }}>
//                                                     <Button onClick={() => fetchTestData(
//                                                         'data',
//                                                         test.quiz_id,
//                                                         test.n_level
//                                                     )}
//                                                         size="small"
//                                                     >
//                                                         View
//                                                     </Button>
//                                                 </TableCell>
//                                             </TableRow>

//                                         ))
//                                         :
//                                         <TableRow>
//                                             <TableCell colSpan={5}>
//                                                 <Typography sx={{ textAlign: 'center' }}>{metaTableMsg}</Typography>
//                                             </TableCell>
//                                         </TableRow>
//                                     }
//                                 </TableBody>
//                             </Table>
//                         </Box>

//                         {(testMeta.length > 0) &&
//                             <Box sx={{ textAlign: 'center', py: 1 }}>
//                                 <Button onClick={() => { changePage('back', page) }}>Prev</Button>
//                                 {<Button>{`${page + 1} | ${Math.ceil(testMeta.length / 4)}`}</Button>}
//                                 <Button
//                                     onClick={() => { changePage('forward', page); setOpen([]) }}>Next</Button>
//                             </Box>
//                         }
//                     </TableContainer>
//                 </Grid>
//                 {/* spotlight card */}
//                 <Grid size={(matches) ? 7 : 12}>
//                     <Paper sx={{ py: 2, px: 4 }}>
//                         {(spotlightCard.length > 0) ?
//                             <Box>
//                                 <Box>
//                                     <Typography sx={{ textAlign: 'center', fontWeight: '700', fontSize: { xs: '2.5rem', md: '3rem' } }}>
//                                         {spotlightCard[0].slug}
//                                     </Typography>
//                                 </Box>
//                                 <Box sx={{ py: 1 }}>
//                                     {[...new Set(spotlightCard[0].japanese.map(y => y.word))].map((z, zindex) => (
//                                         <Typography key={zindex} sx={{ fontWeight: '700', fontSize: { xs: '1.8rem', md: '2rem' } }}>{z}</Typography>
//                                     ))}

//                                     <Typography gutterBottom sx={{ color: 'orange', mt: 1, fontWeight: '700', fontSize: { xs: '1.2rem', md: '1.5rem' } }}>Reading</Typography>

//                                     {[...new Set(spotlightCard[0].japanese.map((x => x.reading)))].map(b => (
//                                         <Typography key={b} sx={{ fontWeight: '700', fontSize: { xs: '1.2rem', md: '1.2rem' } }}>{b}</Typography>
//                                     ))}

//                                     <Typography gutterBottom sx={{ color: 'orange', mt: 1, fontWeight: '700', fontSize: { xs: '1.2rem', md: '1.5rem' } }}>Meaning</Typography>

//                                     <Box sx={{ mb: 1 }}>
//                                         {spotlightCard[0].senses.map((x, senseIndex) => (
//                                             x.parts_of_speech != 'Wikipedia definition' && x.parts_of_speech != 'Place' && x.parts_of_speech != 'Full name' ?
//                                                 <Box key={senseIndex}>

//                                                     {x.parts_of_speech.map((f, posIndex) => (
//                                                         <Typography key={posIndex} sx={{ color: 'grey', fontSize: { xs: '1.2rem', md: '1.5rem' } }}>
//                                                             {f}
//                                                         </Typography>
//                                                     ))}

//                                                     {x.tags.map((g, tagIndex) => (
//                                                         <Typography key={tagIndex} sx={{ color: 'grey', fontSize: { xs: '1.2rem', md: '1.5rem' } }}>
//                                                             {g}
//                                                         </Typography>
//                                                     ))}

//                                                     <Typography sx={{ mb: 1, fontSize: { xs: '1.2rem', md: '1.5rem' } }}>
//                                                         {x.english_definitions.join(', ')}
//                                                     </Typography>
//                                                 </Box>
//                                                 : null
//                                         ))}
//                                     </Box>
//                                 </Box>
//                             </Box> :
//                             <Box>
//                                 <Box>
//                                     <Typography sx={{ textAlign: 'center', fontWeight: '700', fontSize: { xs: '2.5rem', md: '3rem' } }}>
//                                         復習
//                                     </Typography>
//                                 </Box>
//                                 <Box sx={{ py: 1 }}>

//                                     <Typography gutterBottom sx={{ color: 'orange', mt: 1, fontWeight: '700', fontSize: { xs: '1.2rem', md: '1.5rem' } }}>Reading</Typography>

//                                     <Typography sx={{ fontWeight: '700', fontSize: { xs: '1.2rem', md: '1.2rem' } }}>ふくしゅう</Typography>

//                                     <Typography gutterBottom sx={{ color: 'orange', mt: 1, fontWeight: '700', fontSize: { xs: '1.2rem', md: '1.5rem' } }}>Meaning</Typography>

//                                     <Box sx={{ mb: 1 }}>

//                                         <Box>

//                                             <Typography sx={{ color: 'grey', fontSize: { xs: '1.2rem', md: '1.5rem' } }}>
//                                                 {`Noun (futsuumeishi)`}
//                                             </Typography>

//                                             <Typography sx={{ color: 'grey', fontSize: { xs: '1.2rem', md: '1.5rem' } }}>
//                                                 Takes the aux. verb suru
//                                             </Typography>

//                                             <Typography sx={{ color: 'grey', fontSize: { xs: '1.2rem', md: '1.5rem' } }}>
//                                                 Transitive verb
//                                             </Typography>

//                                             <Typography sx={{ mb: 1, fontSize: { xs: '1.2rem', md: '1.5rem' } }}>
//                                                 {`review (of learned material), revision`}
//                                             </Typography>
//                                         </Box>
//                                     </Box>
//                                 </Box>
//                             </Box>
//                         }
//                     </Paper>
//                 </Grid>
//                 {/* test details */}
//                 <Grid size={(matches) ? 5 : 12}>
//                     <TableContainer component={Paper} sx={{ py: 2, px: 4, display: 'flex', flexDirection: 'column' }}>
//                         <Box sx={{}}>
//                             <Table size="small">
//                                 <TableHead>
//                                     <TableRow>
//                                         <TableCell sx={{ textAlign: 'left', fontSize: { xs: '0.8rem', md: '1.3rem' } }}>Word</TableCell>
//                                         <TableCell sx={{ textAlign: 'left', fontSize: { xs: '0.8rem', md: '1.3rem' } }}>Result</TableCell>
//                                         <TableCell sx={{ textAlign: 'left', fontSize: { xs: '0.8rem', md: '1.3rem' } }}></TableCell>
//                                     </TableRow>
//                                 </TableHead>
//                                 <TableBody>
//                                     {(testCardsSliced.length > 0) ?
//                                         testCardsSliced.map((word, index) => (
//                                             <TableRow key={index}>
//                                                 <TableCell sx={{ textAlign: 'left', width: '90%', fontSize: { xs: '0.8rem', md: '1.3rem' } }}>
//                                                     {word.slug}
//                                                 </TableCell>
//                                                 <TableCell sx={{ textAlign: 'left', width: '5%', fontSize: { xs: '0.8rem', md: '1.3rem' } }}>
//                                                     {word.result === true ? 'Correct' : 'Incorrect'}
//                                                 </TableCell>
//                                                 <TableCell sx={{ textAlign: 'left', width: '5%', fontSize: { xs: '0.8rem', md: '1.3rem' } }}>
//                                                     <Button
//                                                         sx={{ fontSize: { xs: '0.8rem', md: '1.3rem' } }}
//                                                         onClick={() => {
//                                                             setSpotlightCard(testCardsSliced.filter(x => x.id === word.id))
//                                                             console.log('spotlight', testCardsSliced.filter(x => x.id === word.id))
//                                                         }
//                                                         }
//                                                         size="small"
//                                                     >
//                                                         Details
//                                                     </Button>
//                                                 </TableCell>
//                                             </TableRow>
//                                         ))
//                                         :

//                                         <TableRow>
//                                             <TableCell colSpan={7}>
//                                                 <Typography sx={{ textAlign: 'center' }}>{detailTableMsg}</Typography>
//                                             </TableCell>
//                                         </TableRow>

//                                     }
//                                 </TableBody>
//                             </Table>
//                         </Box>

//                         {/* test data pagination buttons */}

//                         {(testCards.length > 0) &&
//                             <Box sx={{ textAlign: 'center', mt: 2 }}>
//                                 <Button onClick={() => { changeTCpage('back', tcPage) }}>Prev</Button>
//                                 {<Button>{`${tcPage + 1} | ${Math.ceil(testCards.length / 10)}`}</Button>}
//                                 <Button onClick={() => { changeTCpage('forward', tcPage) }}>Next</Button>
//                             </Box>
//                         }

//                     </TableContainer>
//                 </Grid>
//             </Grid>
//             <Dialog open={testDetailDialog} onClose={() => toggleTestDetailDialog(false)}>
//                 <DialogTitle textAlign="center">Test Details</DialogTitle>
//                 <DialogContent>
//                     <Table size="small">
//                         <TableBody>
//                             {(testDetail) ?
//                                 <>
//                                     <TableRow>
//                                         <TableCell sx={{ fontWeight: '600' }}>Test Type</TableCell>
//                                         <TableCell sx={{}}>{capitalizeFirstLetter(testDetail.quiz_type)}</TableCell>
//                                     </TableRow>
//                                     <TableRow>
//                                         <TableCell sx={{ fontWeight: '600' }}>Random</TableCell>
//                                         <TableCell sx={{}}>{testDetail.random === true ? 'True' : 'False'}</TableCell>
//                                     </TableRow>
//                                     <TableRow>
//                                         <TableCell sx={{ fontWeight: '600' }}>Correct</TableCell>
//                                         <TableCell sx={{}}>{testDetail.correct}</TableCell>
//                                     </TableRow>
//                                     <TableRow>
//                                         <TableCell sx={{ fontWeight: '600' }}>Incorrect</TableCell>
//                                         <TableCell sx={{}}>{testDetail.incorrect}</TableCell>
//                                     </TableRow>
//                                     <TableRow>
//                                         <TableCell sx={{ fontWeight: '600' }}>Start Page</TableCell>
//                                         <TableCell sx={{}}>{testDetail.start_from}</TableCell>
//                                     </TableRow>
//                                 </>
//                                 :
//                                 <TableRow>
//                                     <TableCell colSpan={9}>
//                                         <Typography sx={{ textAlign: 'center' }}>No data available</Typography>
//                                     </TableCell>
//                                 </TableRow>
//                             }
//                         </TableBody>
//                     </Table>
//                 </DialogContent>
//             </Dialog>
//         </Container >


//     )
// }
// export default ReviewComponent